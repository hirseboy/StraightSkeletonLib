#include "SS_Polygon.h"
#include "SS_Functions.h"
#include "SS_Constants.h"

#include <math.h>
#include <IBK_assert.h>
#include <IBK_Line.h>

namespace SKELETON {

Polygon::Polygon(const std::vector<IBK::point2D<double> > &points)
{
    for (size_t i=0; i<points.size(); ++i) {
		m_points.push_back(Point(points[i]));
    }

    // set m_bisectors
    setBisectors();
}

Polygon::~Polygon()
{
    m_points.clear();
    m_bisectors.clear();
    m_lines.clear();
    m_lineVectors.clear();
}

bool Polygon::setBisectors()
{
    setVectors();
    m_bisectors.clear();
    
    size_t iB;
    
    for(size_t i=0; i<size(); ++i)
    {
        iB = (i-1) % size();     
        IBKMK::Vector3D vBisector = m_lineVectors[i] + m_lineVectors[iB];
        vBisector.normalize();
        
        m_bisectors.push_back(vBisector);
    }
    return true;
}

bool Polygon::setVectors()
{   
    m_lineVectors.clear();
    
    size_t iN;
    for (size_t i=0; i<size(); ++i) {
        iN = (i+1)%size();
        // first store points that need to be deleted
        m_lineVectors.push_back( SKELETON::vector(m_points[iN], m_points[i], true) );
    }
    return true;
}

bool Polygon::setLines()
{
    return true;
}

IBK::point2D<double> Polygon::bisectorIntersection(size_t lineIdx)
{
    size_t iN, iB;
    iN = (lineIdx+1) % size();
    iB = (lineIdx-1) % size();
    
    Point p1 = m_points[iN].addVector(m_lineVectors[iN], SKELETON::MAX_SCALE);
    Point p2 = m_points[iN].addVector(m_lineVectors[iN], SKELETON::MAX_SCALE);
    
    IBK::Line l1 ( m_points[iN].toIbkPoint(), p1.toIbkPoint() );
    IBK::Line l2 ( m_points[iB].toIbkPoint(), p2.toIbkPoint() );
    
    l1.intersects(l2, )
}

template <size_t digits>
bool Polygon::pointOnPoint(IBK::point2D<double> &point)
{
    bool onPoint=false;
	for (unsigned int i=0; i<this->size(); ++i)
	{
		if( IBK::nearly_equal<digits>(  ) ){
			onPoint=!onPoint;
		}
	}
	return onPoint;
}

template <size_t digits>
bool Polygon::pointOnLine(IBK::point2D<double> &point)
{
    size_t iN;
    IBK::Line line;
    for (size_t i=0; i<size(); ++i)
        if (SKELETON::pointOnLine(point, m_lines[i]))
            return true;
    return false;
}

size_t Polygon::size() const
{
    return (int)m_points.size();
}

IBK::point2D<double> Polygon::bisector(const size_t &pointIdx)
{
    return IBK::point2D<double>(0.0,0.0);
}

double Polygon::distanceToLine(const size_t &pointIdx)
{
    return 0.0;
}

Polygon::Event Polygon::split(size_t splitIdx)
{
    IBK_ASSERT(m_events[splitIdx].m_isSplit)
    return m_events(splitIdx);
}

Polygon::Event Polygon::edge(size_t edgeIdx)
{
    IBK_ASSERT(!m_events[edgeIdx].m_isSplit)
    return m_events[edgeIdx];
}

bool Polygon::sortEvents()
{
    std::sort(m_events.begin(), m_events.end());
    return true;
}

bool Polygon::checkSanity()
{
    size_t iN;
    std::vector<size_t> delPoints;
    // check if two or more points have the same coordinates
    for (size_t i=0; i<size(); ++i) {
            iN = (i+1)%size();
            // first store points that need to be deleted
            if ( SKELETON::checkPoints<4>(m_points[i], m_points[iN]) ) {
                delPoints.push_back(iN);
            }
    }
    // delete points
    for (std::vector<size_t>::reverse_iterator i = delPoints.rbegin();
         i != delPoints.rend(); ++i) {
        int test = *i;
        m_points.erase( m_points.begin() + (int)*i );
    }
    return true;
}



}
